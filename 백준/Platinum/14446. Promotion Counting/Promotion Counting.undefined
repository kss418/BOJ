#include <bits/stdc++.h>
#define fastio cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
#define all(x) (x).begin(), (x).end()
#define x first 
#define y second
using namespace std; using ll = long long; using u64 = uint64_t;
using ld = long double; using pld = pair<ld, ld>;
using i128 = __int128_t; using f128 = __float128; 
using pll = pair<ll, ll>; using tll = tuple<ll, ll, ll>;
ll n, m, k, t = 1; string s;

constexpr ll INF = 0x3f3f3f3f3f3f3f3f;
constexpr ll MINF = 0xc0c0c0c0c0c0c0c0;
constexpr ll MAX = 101010; // SET MAX SIZE
constexpr ll MOD = 998244353;
int a[MAX], p[MAX], in[MAX], out[MAX], cnt;
vector <int> adj[MAX];

struct mt_policy {
    struct node {
        int v;
        node(int v) : v(v){}
        node() : node(0){} // identity
        bool operator < (const node& ot) const{ return v < ot.v; }
    };
};

template <class policy = mt_policy>
class _mt{ // 1-based index
public:
    using node = typename policy::node;
private:
    vector <vector <node>> seg;
    vector <node> arr; int n, sz = 1;
    static int count_node(const vector<node>& cur, const node& v, bool is_greater, bool is_less, bool is_eq){
        int ret = 0;
        auto lb = lower_bound(cur.begin(), cur.end(), v);
        auto ub = upper_bound(cur.begin(), cur.end(), v);
        if(is_eq) ret += (int)(ub - lb);                  
        if(is_greater) ret += (int)(cur.end() - ub);
        if(is_less) ret += (int)(lb - cur.begin());
        return ret; 
    }

    int query(int st, int en, const node& v, bool is_greater, bool is_less, bool is_eq) const{
        st = max(st, 1); en = min(en, n);
        if(n <= 0 || st > en) return 0;
        int l = sz + st - 1, r = sz + en - 1, ret = 0;
        while(l <= r){
            if(l & 1) ret += count_node(seg[l++], v, is_greater, is_less, is_eq);
            if(!(r & 1)) ret += count_node(seg[r--], v, is_greater, is_less, is_eq);
            l >>= 1; r >>= 1;
        }
        return ret;
    }
public:
    _mt(int n = 0){ clear(n); } // O(n)
    _mt(const vector <node>& arr){ build(arr); } // O(n log n)
    void clear(int n){ // O(n)
        this->n = n; sz = 1; while(sz < n) sz <<= 1; 
        arr.assign(n + 1, node()); seg.assign(2 * sz, {});
    }

    void build(const vector <node>& arr){ // O(n log n)
        clear((int)arr.size() - 1); this->arr = arr; 
        for(int i = 1; i <= n; i++) seg[sz + i - 1].assign(1, arr[i]);
        for(int i = sz - 1; i >= 1; i--){
            auto &l = seg[i << 1], &r = seg[i << 1 | 1], &cur = seg[i];
            cur.resize(l.size() + r.size());
            merge(all(l), all(r), cur.begin());
        }
    }

    void update(int idx, const node& v){ // O(n)
        if(idx < 1 || idx > n) return; arr[idx] = v;
        int p = sz + idx - 1; seg[p].assign(1, v); 
        for(int i = p >> 1;i >= 1;i >>= 1){
            auto &l = seg[i << 1], &r = seg[i << 1 | 1], &cur = seg[i];
            cur.resize(l.size() + r.size());
            merge(all(l), all(r), cur.begin());
        }
    }

    int greater(int st, int en, const node& v) const{ return query(st, en, v, 1, 0, 0); } // O(log^2 n)
    int less(int st, int en, const node& v) const{ return query(st, en, v, 0, 1, 0); } // O(log^2 n)
    int geq(int st, int en, const node& v) const{ return query(st, en, v, 1, 0, 1); } // O(log^2 n)
    int leq(int st, int en, const node& v) const{ return query(st, en, v, 0, 1, 1); } // O(log^2 n)
    int eq(int st, int en, const node& v) const{ return query(st, en, v, 0, 0, 1); } // O(log^2 n)
};

void dfs(int cur = 1){
    in[cur] = ++cnt;
    for(auto& nxt : adj[cur]) dfs(nxt);
    out[cur] = cnt;
}

void run(){
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> a[i];
    for(int i = 2;i <= n;i++) cin >> p[i], adj[p[i]].push_back(i);
    dfs();
    
    vector <mt_policy::node> arr(n + 1);
    for(int i = 1;i <= n;i++) arr[in[i]].v = a[i];
    _mt mt(arr);

    for(int i = 1;i <= n;i++) cout << mt.greater(in[i], out[i], a[i]) << "\n";
}

int main() {
    fastio; // cin >> t;
    while(t--) run(); 

    return 0;
}